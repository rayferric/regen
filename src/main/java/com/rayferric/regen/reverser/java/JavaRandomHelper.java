package com.rayferric.dungeonseed;

import com.rayferric.regen.reverser.LCG;
import com.rayferric.regen.reverser.java.JavaRandom;

import java.util.ArrayList;
import java.util.List;
import java.util.stream.LongStream;

public class JavaRandomHelper {
    public static final LCG REVERSE_LCG = LCG.JAVA.ofStep(-1);

    /**
     * Expands a 48-bit number to a 64-bit forms that could've been generated by {@link JavaRandom#nextLong()}.
     *
     * @param seed 48-bit long
     *
     * @return a stream of 64-bit expanded longs
     */
    public static LongStream expand48(long seed) {
        seed = seed & MASK_48;

        List<Long> seeds = new ArrayList<>();

        // Extract individual parts that had to be merged to produce this long:
        int int1 = firstIntFromNextLong(seed); // 16-bit
        int int2 = (int)seed;

        long bits2 = Integer.toUnsignedLong(int2);

        // Iterate over all 16-bit numbers:
        for(long i = 0; i < (1L << 16); i++) {
            // Append to the lower 32 bits (we are brute forcing next(32)):
            long seed2 = (bits2 << 16) | i;
            long seed1 = REVERSE_LCG.next(seed2);

            // If the middle 16 bits of the first seed (lower 16-bits of bits1) are equal to bits1:
            if(((int)(seed1 >>> 16) & MASK_16) == int1) {
                // We must go one step back and generate a long using seed1 (and seed2):
                JavaRandom rand = new JavaRandom(REVERSE_LCG.next(seed1));
                seeds.add(rand.nextLong());
            }
        }

        return seeds.stream().mapToLong(x -> x);
    }

    /**
     * Recovers the seed that was used to generate a next long.
     *
     * @param value the value returned by nextLong()
     *
     * @return internal seed
     *
     * @throws IllegalArgumentException if passed long is not a product of the Java RNG
     */
    public static long seedFromNextLong(long value) {
        // https://stackoverflow.com/a/15237585

        long mul = LCG.JAVA.getMultiplier();
        long mulInv = REVERSE_LCG.getMultiplier();
        long add = LCG.JAVA.getAddend();

        int int1 = firstIntFromNextLong(value);
        int int2 = (int)value;

        long bits1 = Integer.toUnsignedLong(int1);
        long bits2 = Integer.toUnsignedLong(int2);

        long q = ((bits2 << 16) - add - (bits1 << 16) * mul) & MASK_48;
        for(long i = 0L; i < 6L; i++) {
            long rem = (mul - (q + (i << 48))) % mul;
            long d = (rem + mul) % mul;

            if(d < (1L << 16)) {
                long c = ((q + d) * mulInv) & MASK_48;

                if(c < (1L << 16)) {
                    return ((((bits1 << 16) + c) - add) * mulInv) & MASK_48;
                }
            }
        }

        // Sometimes fails... e.g 107347286252143874
        // Let's fall back to bruteforce:

        JavaRandom rand = new JavaRandom(0L);
        for(long i = 0L; i < (1L << 16); i++) {
            long seed1 = (bits1 << 16) | i;
            rand.setSeed(seed1);
            if(rand.nextInt() == int2)
                return REVERSE_LCG.next(seed1);
        }

        throw new IllegalArgumentException("This long was not generated by the Java RNG: " + value);
    }

    /**
     * Extracts the first next(32) call from a long produced by nextLong().
     *
     * @param nextLong long value produced by the Java RNG
     *
     * @return value of the first next(32) call
     */
    public static int firstIntFromNextLong(long nextLong) {
        return (int)((nextLong >>> 32) + ((nextLong >>> 31) & 1L));
    }

    private static final long MASK_16 = (1L << 16) - 1L;
    private static final long MASK_48 = (1L << 48) - 1L;
}
